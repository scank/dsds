# 函数调用关系详细分析

## 1. 系统初始化调用链

### 主函数初始化序列
```c
int main(void)
{
    // 1. HAL库初始化
    HAL_Init();
    
    // 2. 系统时钟配置
    SystemClock_Config();
    
    // 3. 外设初始化
    MX_GPIO_Init();           // GPIO初始化
    MX_USART1_UART_Init();    // UART1初始化(调试)
    MX_USART2_UART_Init();    // UART2初始化(RS485)
    MX_USART3_UART_Init();    // UART3初始化(备用)
    MX_TIM13_Init();          // 定时器13初始化(Modbus超时)
    MX_TIM14_Init();          // 定时器14初始化(状态检测)
    MX_TIM11_Init();          // 定时器11初始化(均值计算)
    MX_TIM10_Init();          // 定时器10初始化(数据采集)
    MX_TIM7_Init();           // 定时器7初始化(调试输出)
    
    // 4. 应用层初始化
    KY5530_ALL_Init();        // KY5530 ADC初始化
    kalman_ALL_init();        // 卡尔曼滤波器初始化
    arm_iir_all_init();       // IIR滤波器初始化
    protocol_init();          // 协议栈初始化
    
    // 5. 启动定时器
    HAL_TIM_Base_Start_IT(&htim10);  // 启动数据采集定时器
    HAL_TIM_Base_Start_IT(&htim7);   // 启动调试输出定时器
    
    // 6. 进入主循环
    while(1) {
        // 主循环处理
    }
}
```

## 2. KY5530 ADC初始化调用链

### KY5530_ALL_Init() 详细调用
```c
void KY5530_ALL_Init(void)
{
    // 通道1初始化
    ky5530_channel = 1;
    KY5532_Init();
    KY5532_ch0_continue_start();
    
    // 通道2初始化
    ky5530_channel = 2;
    KY5532_Init();
    KY5532_ch0_continue_start();
    
    // ... 通道3-6类似
    
    // 通道6初始化
    ky5530_channel = 6;
    KY5532_Init();
    KY5532_ch0_continue_start();
}
```

### KY5532_Init() 内部调用链
```c
void KY5532_Init(void)
{
    // 根据参数配置ADC
    switch(lvbocanshu) {
        case 1: // 25Hz
            KY5532_Config(adc_pga_indx_32, adc_speed_indx_25);
            break;
        case 2: // 50Hz
            KY5532_Config(adc_pga_indx_32, adc_speed_indx_50);
            break;
        case 3: // 100Hz
            KY5532_Config(adc_pga_indx_32, adc_speed_indx_100);
            break;
        case 4: // 1500Hz
            KY5532_Config(adc_pga_indx_8, adc_speed_indx_800);
            break;
    }
}
```

### KY5532_Config() 详细调用
```c
uint8_t KY5532_Config(KY553x_PGA_Type pgaIndx, KY553x_SPEED_Type speedIndx)
{
    // 1. GPIO初始化
    KY5532_gpio_init();
    
    // 2. 停止转换
    KY5532_Convert_Stop();
    
    // 3. 复位和配置
    KY5532_SPI_Reset();
    
    // 4. 配置转换参数
    KY5532_conv_cfg(pgaIndx, speedIndx);
    
    // 5. 配置系统参数
    // SYS_CONF0, SYS_CONF1, SYS_CONF2配置
    
    return 1;
}
```

## 3. 数据采集与处理调用链

### TIM10中断处理 (1500Hz数据采集)
```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM10) {
        // 1. 读取ADC数据
        control_ky5532_readADC(1);
        
        // 2. 卡尔曼滤波
        kalman_filter(&KY1_Kalman, ky1_value);
        
        // 3. IIR滤波
        arm_biquad_cascade_df1_f32(&S1, &KY1_Kalman.x, outputF32_1, BLOCK_SIZE);
        
        // 4. 更新滤波输出
        KY1_IIR_out = testOutput1[0] * ScaleValue;
        
        // 5. LED指示
        HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
    }
}
```

### control_ky5532_readADC() 调用链
```c
uint8_t control_ky5532_readADC(uint8_t channel)
{
    switch(channel) {
        case 1:
            ky5530_channel = 1;
            return KY5532_read_adcVal(&ky1_value);
        case 2:
            ky5530_channel = 2;
            return KY5532_read_adcVal(&ky2_value);
        // ... 其他通道
    }
}
```

### KY5532_read_adcVal() 详细调用
```c
uint8_t KY5532_read_adcVal(int32_t *value)
{
    // 1. 超时检查
    if(KY5532_getVal_timeout_ms > 5000) {
        // 处理超时情况
        return 0xFF;
    }
    
    // 2. 等待转换完成
    while(KY5532_DO_Boolean() == KY_TRUE) {
        return 0;
    }
    
    // 3. 读取数据
    KY5532_cs_low();
    KY5532_send_byte(0x56);
    ret = KY5532_read4byte(&adcDat);
    KY5532_cs_high();
    
    // 4. 数据转换
    temp32 = (adcDat & 0X7FFFFFFF) >> 1;
    *value = (temp32 ^ (0x20000000)) - (0x20000000);
    
    return ret;
}
```

## 4. 信号处理算法调用链

### 卡尔曼滤波调用
```c
float kalman_filter(kalman_struct *kalman_lcw, float measure)
{
    // 1. 预测步骤
    kalman_lcw->x = kalman_lcw->A * kalman_lcw->x;
    kalman_lcw->p = kalman_lcw->A * kalman_lcw->A * kalman_lcw->p + kalman_lcw->q;
    
    // 2. 更新步骤
    kalman_lcw->gain = kalman_lcw->p * kalman_lcw->H / 
                       (kalman_lcw->p * kalman_lcw->H * kalman_lcw->H + kalman_lcw->r);
    kalman_lcw->x = kalman_lcw->x + kalman_lcw->gain * 
                    (measure - kalman_lcw->H * kalman_lcw->x);
    kalman_lcw->p = (1 - kalman_lcw->gain * kalman_lcw->H) * kalman_lcw->p;
    
    return kalman_lcw->x;
}
```

### IIR滤波调用
```c
// ARM DSP库IIR滤波
arm_biquad_cascade_df1_f32(&S1, &KY1_Kalman.x, outputF32_1, BLOCK_SIZE);
```

## 5. 均值计算调用链 (TIM11中断)

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM11) {
        static uint16_t TIM11_num = 0;
        
        if(TIM11_num < junzhi_num) {
            // 累加数据
            KY1_ACC += KY1_IIR_out;
            KY2_ACC += KY2_IIR_out;
            // ... 其他通道
            TIM11_num++;
        } else {
            // 计算平均值
            TIM11_num = 0;
            KY1_ave = KY1_ACC / junzhi_num;
            KY2_ave = KY2_ACC / junzhi_num;
            // ... 其他通道
            
            // 清零累加器
            KY1_ACC = 0;
            KY2_ACC = 0;
            // ... 其他通道
        }
    }
}
```

## 6. 状态检测调用链 (TIM14中断)

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM14) {
        // 1. 动态/稳态检测
        if(KY1_IIR_out_old != (int32_t)KY1_IIR_out/2000) {
            KY1_runing = 1;  // 动态状态
        } else {
            KY1_runing = 0;  // 稳态状态
        }
        KY1_IIR_out_old = (int32_t)KY1_IIR_out/2000;
        
        // 2. 超量程检测
        if(KY1_printf > 1000 || KY1_printf < -100) {
            KY1_warning = 1;
        } else {
            KY1_warning = 0;
        }
        
        // 3. 去皮操作
        if(KY1_qvpi == 1) {
            measure_value1 = KY1_ave;
            KY1_qvpi = 0;
        }
        
        // 4. 标定操作
        if(KY1_biaoding == 1) {
            KY1_xishu = (KY1_ave - measure_value1) / 20.0f;
            KY1_biaoding = 0;
        }
    }
}
```

## 7. Modbus通信调用链

### 主循环中的Modbus处理
```c
while(1) {
    // 1. 读取ADC数据
    control_ky5532_readADC(1);
    
    // 2. 计算实际重量
    actual_weight1 = ((float)kalman_filter(&test_Kalman, meanFilter2(ky1_value)) - tare_weight1) / 2836;
    
    // 3. 更新Modbus寄存器
    modbus_virtual_register[0] = (uint16_t)(KY1_mod & 0x0000FFFF);
    modbus_virtual_register[1] = (KY1_mod & 0xFFFF0000) >> 16;
    // ... 其他寄存器更新
    
    // 4. 处理Modbus通信
    modbus_service();
}
```

### modbus_service() 调用链
```c
void modbus_service(void)
{
    if(Flag_of_Modbus_Ok == 1) {
        // 1. CRC校验
        CRC_check_result = CRC16(RS485_RX_BUF, data_len-2);
        
        if(CRC_check_result == data_CRC_value) {
            if(RS485_RX_BUF[0] == modbus_slave_addr) {
                switch(RS485_RX_BUF[1]) {
                    case 03:  // 读寄存器
                        modbus_03_function();
                        break;
                    case 06:  // 写单寄存器
                        modbus_06_function();
                        break;
                    case 16:  // 写多寄存器
                        modbus_16_function();
                        break;
                }
            }
        }
        Flag_of_Modbus_Ok = 0;
    }
}
```

### modbus_03_function() 详细调用
```c
void modbus_03_function(void)
{
    // 1. 准备响应数据
    modbus_Tx_buff[0] = modbus_slave_addr;
    modbus_Tx_buff[1] = 03;
    
    // 2. 读取寄存器数据
    register_len = RS485_RX_BUF[5] | (((uint16_t)RS485_RX_BUF[4]) << 8);
    register_start = RS485_RX_BUF[3] | (((uint16_t)RS485_RX_BUF[2]) << 8);
    
    // 3. 填充数据
    for(i=0; register_len > i; i++, register_start++) {
        modbus_Tx_buff[arr_start] = modbus_virtual_register[register_start] >> 8 & 0xFF;
        arr_start++;
        modbus_Tx_buff[arr_start] = modbus_virtual_register[register_start] & 0xFF;
        arr_start++;
    }
    
    // 4. 计算CRC并发送
    arr_start = CRC16(modbus_Tx_buff, register_len*2+3);
    modbus_Tx_buff[register_len*2+3] = (arr_start) & 0xFF;
    modbus_Tx_buff[register_len*2+4] = (arr_start>>8) & 0xFF;
    modbus_send_data(modbus_Tx_buff, register_len*2+5);
}
```

## 8. 调试输出调用链 (TIM7中断)

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM7) {
        // 1. 处理Modbus通信
        modbus_service();
        
        // 2. 调试输出
        #if printf_debug
        printf("%d\r\n", ky1_value);
        #endif
    }
}
```

## 9. 关键数据结构关系

### 全局变量关系图
```
main.c 全局变量
├── 6通道ADC原始值 (ky1_value ~ ky6_value)
├── 6通道卡尔曼滤波器 (KY1_Kalman ~ KY6_Kalman)
├── 6通道平均值 (KY1_ave ~ KY6_ave)
├── 6通道最终重量值 (KY1_printf ~ KY6_printf)
├── 6通道状态标志 (KY1_runing, KY1_warning, KY1_qvpi, KY1_biaoding)
└── Modbus虚拟寄存器 (modbus_virtual_register[550])
```

### 函数调用层次结构
```
Level 1: main()
├── Level 2: 初始化函数
│   ├── KY5530_ALL_Init()
│   ├── kalman_ALL_init()
│   ├── arm_iir_all_init()
│   └── protocol_init()
├── Level 2: 中断处理函数
│   ├── HAL_TIM_PeriodElapsedCallback()
│   └── 各种中断服务程序
└── Level 2: 主循环处理
    ├── control_ky5532_readADC()
    ├── kalman_filter()
    └── modbus_service()
```

## 10. 内存使用分析

### 栈使用情况
- **主栈**: 系统初始化和主循环
- **中断栈**: 定时器中断处理
- **函数调用栈**: 深度约3-4层

### 堆使用情况
- **静态分配**: 全局变量和数组
- **动态分配**: ARM DSP库内部使用

### 关键内存区域
```c
// 全局变量区域
int32_t ky1_value ~ ky6_value;           // 6 * 4 = 24 bytes
kalman_struct KY1_Kalman ~ KY6_Kalman;   // 6 * 28 = 168 bytes
float32_t KY1_ave ~ KY6_ave;             // 6 * 4 = 24 bytes
uint16_t modbus_virtual_register[550];   // 550 * 2 = 1100 bytes

// 总计约 1316 bytes 全局数据
```

这个详细的函数调用关系分析展示了整个系统的运行机制，从初始化到数据处理，再到通信协议的完整流程。
